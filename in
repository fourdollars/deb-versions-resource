#!/bin/bash

set -euo pipefail

exec 3>&1
exec 1>&2
jq -M -S . < /dev/stdin > /tmp/input.json

if [ "$(jq -r '.source | has("codename")' < /tmp/input.json)" = 'true' ]; then
    codename="$(jq -r .source.codename < /tmp/input.json)"
else
    codename=''
fi

if [ -z "$codename" ]; then
    distro=''
    mirror=''
elif command -v ubuntu-distro-info >/dev/null && [[ "$(ubuntu-distro-info --all)" =~ $codename ]]; then
    distro='ubuntu'
    mirror='http://archive.ubuntu.com/ubuntu/'
elif command -v debian-distro-info >/dev/null && [[ "$(debian-distro-info --all)" =~ $codename ]]; then
    distro='debian'
    mirror='http://deb.debian.org/debian/'
else
    distro=''
    mirror=''
fi

if [ "$(jq -r '.source | has("mirror")' < /tmp/input.json)" = 'true' ]; then
    mirror="$(jq -r .source.mirror < /tmp/input.json)"
fi

if [ "$(jq -r '.source | has("archive")' < /tmp/input.json)" = 'true' ]; then
    case "$(jq -r '.source.archive | type' < /tmp/input.json)" in
        ('string')
            archive=("$(jq -r .source.archive < /tmp/input.json)")
            ;;
        ('array')
            mapfile -t archive < <(jq -r '.source.archive | .[]' < /tmp/input.json)
            ;;
        (*)
            echo "Invalid input for .source.archive"
            exit 1
            ;;
    esac
else
    archive=()
fi

if [ "$(jq -r '.source | has("username")' < /tmp/input.json)" = 'true' ]; then
    case "$(jq -r '.source.username | type' < /tmp/input.json)" in
        ('string')
            username=("$(jq -r .source.username < /tmp/input.json)")
            ;;
        ('array')
            mapfile -t username < <(jq -r '.source.username | .[]' < /tmp/input.json)
            ;;
        (*)
            echo "Invalid input for .source.username"
            exit 1
            ;;
    esac
else
    username=()
fi

if [ "$(jq -r '.source | has("password")' < /tmp/input.json)" = 'true' ]; then
    case "$(jq -r '.source.password | type' < /tmp/input.json)" in
        ('string')
            password=("$(jq -r .source.password < /tmp/input.json)")
            ;;
        ('array')
            mapfile -t password < <(jq -r '.source.password | .[]' < /tmp/input.json)
            ;;
        (*)
            echo "Invalid input for .source.password"
            exit 1
            ;;
    esac
else
    password=()
fi

if [ "$(jq -r '.source | has("fingerprint")' < /tmp/input.json)" = 'true' ]; then
    case "$(jq -r '.source.fingerprint | type' < /tmp/input.json)" in
        ('string')
            fingerprint=("$(jq -r .source.fingerprint < /tmp/input.json)")
            ;;
        ('array')
            mapfile -t fingerprint < <(jq -r '.source.fingerprint | .[]' < /tmp/input.json)
            ;;
        (*)
            echo "Invalid input for .source.fingerprint"
            exit 1
            ;;
    esac
else
    fingerprint=()
fi

if [ "$(jq -r '.source | has("packages")' < /tmp/input.json)" = 'true' ]; then
    case "$(jq -r '.source.packages | type' < /tmp/input.json)" in
        ('string')
            packages=("$(jq -r '.source.packages')")
            ;;
        ('array')
            mapfile -t packages < <(jq -r '.source.packages|.[]' < /tmp/input.json | sort)
            ;;
        (*)
            echo "Invalid input for .source.packages"
            exit 1
            ;;
    esac
else
    packages=()
fi

if [ "$(jq -r '.source | has("download")' < /tmp/input.json)" = 'true' ]; then
    download="$(jq -r .source.download < /tmp/input.json)"
else
    download=''
fi

if [ "$(jq -r '.source | has("proposed")' < /tmp/input.json)" = 'true' ]; then
    proposed="$(jq -r .source.proposed < /tmp/input.json)"
else
    proposed='false'
fi

APTDIR="$(mktemp -d /tmp/apt.XXXXXXXXXX)"
mkdir -p "$APTDIR"/var/lib/apt/lists "$APTDIR"/var/lib/dpkg "$APTDIR"/etc/apt/trusted.gpg.d "$APTDIR"/etc/apt/preferences.d "$APTDIR"/var/lib/dpkg "$APTDIR"/etc/apt/sources.list.d "$APTDIR"/etc/apt/auth.conf.d
:> "$APTDIR"/var/lib/dpkg/status
APTOPT=(-o "Dir=$APTDIR" -o "Dir::State::status=$APTDIR/var/lib/dpkg/status")

case "$distro" in
    ('ubuntu')
        cat > "$APTDIR"/etc/apt/sources.list <<ENDLINE
deb $mirror $codename main restricted universe multiverse
deb $mirror $codename-updates main restricted universe multiverse
deb $mirror $codename-backports main restricted universe multiverse
ENDLINE
        if [ "$proposed" = 'true' ]; then
            echo "deb $mirror $codename-proposed main restricted universe multiverse" >> "$APTDIR"/etc/apt/sources.list
        fi
        ;;
    ('debian')
        cat > "$APTDIR"/etc/apt/sources.list <<ENDLINE
deb $mirror $codename main contrib non-free
deb $mirror $codename-updates main contrib non-free
deb $mirror $codename-backports main contrib non-free
ENDLINE
        ;;
    (*)
        touch "$APTDIR"/etc/apt/sources.list
        ;;
esac

case "$distro" in
    ('ubuntu')
        cp /etc/apt/trusted.gpg.d/ubuntu-keyring-*-archive.gpg "$APTDIR/etc/apt/trusted.gpg.d"
        ;;
    ('debian')
        cp /usr/share/keyrings/debian-archive-*.gpg /etc/apt/trusted.gpg.d
        cp /usr/share/keyrings/debian-archive-*.gpg "$APTDIR/etc/apt/trusted.gpg.d"
        ;;
esac

export APT_KEY_DONT_WARN_ON_DANGEROUS_USAGE=1
for key in "${fingerprint[@]}"; do
    apt-key adv --keyserver keyserver.ubuntu.com --recv-key "$key" >/dev/null
    apt-key adv --output "$APTDIR/etc/apt/trusted.gpg.d/$key.gpg" --export "$key" >/dev/null
done

if [ -e /etc/apt/trusted.gpg ]; then
    cp /etc/apt/trusted.gpg "$APTDIR/etc/apt"
fi

if [ -n "${archive[*]}" ]; then
    for i in "${!archive[@]}"; do
        if [[ "${archive[$i]}" =~ ^ppa: ]]; then
            if [ -z "$codename" ]; then
                echo "You need to provide the codename when using ${archive[$i]}."
                exit 1
            fi
            user=$(echo "${archive[$i]//[:\/]/ }" | awk '{print $2}')
            name=$(echo "${archive[$i]//[:\/]/ }" | awk '{print $3}')
            if [ -z "${username[$i]}" ] || [ -z "${password[$i]}" ] || [ -z "${fingerprint[$i]}" ]; then
                cat > "$APTDIR/etc/apt/sources.list.d/ppa-$user-$name.list" <<ENDLINE
deb http://ppa.launchpad.net/$user/$name/ubuntu $codename main
ENDLINE
            else
                cat > "$APTDIR/etc/apt/auth.conf.d/ppa-$user-$name.conf" <<ENDLINE
machine private-ppa.launchpad.net/$user/$name/ubuntu login ${username[$i]} password ${password[$i]}
ENDLINE
                cat > "$APTDIR/etc/apt/sources.list.d/ppa-$user-$name.list" <<ENDLINE
deb https://private-ppa.launchpad.net/$user/$name/ubuntu $codename main
ENDLINE
            fi
        else
            echo "${archive[$i]}" >> "$APTDIR/etc/apt/sources.list.d/extra.list"
            if [ -n "${username[*]}" ] && [ -n "${password[*]}" ] && [ -n "${username[$i]}" ] && [ -n "${password[$i]}" ]; then
                echo "machine $(echo "${archive[$i]}" | grep -o '[^ ]*://[^ ]*' | sed 's|^[^/]*//||') login ${username[$i]} password ${password[$i]}" >> "$APTDIR/etc/apt/auth.conf.d/extra.conf"
            fi
        fi
    done
fi

apt-get "${APTOPT[@]}" -q -q update

versions=()
sha256=()
for pkg in "${packages[@]}"; do
    if ! apt-cache "${APTOPT[@]}" search ^"$pkg"$ | grep ^"$pkg"; then
        echo "$pkg not found."
        exit 1
    fi
    apt-cache "${APTOPT[@]}" policy "$pkg"
    versions+=("$(apt-cache "${APTOPT[@]}" show "$pkg" | grep ^Version: | head -n1 | awk '{print $2}' || true)")
    sha256+=("$(apt-cache "${APTOPT[@]}" show "$pkg" | grep ^SHA256: | head -n1 | awk '{print $2}' || true)")
done

sha256sum="$(echo "${packages[@]}" "${versions[@]}" "${sha256[@]}" | sha256sum | awk '{print $1}')"

case "$0" in
    ('/opt/resource/check')
        json='[{"sha256":"'"$sha256sum"'"}]'
        ;;
    ('/opt/resource/in')
        json='{"version":{"sha256":"'"$sha256sum"'"},"metadata":['
        metadata=()
        for idx in "${!packages[@]}"; do
            metadata+=('{"name":"'"${packages[$idx]}"'","value":"'"${versions[$idx]}"'"}')
            echo "${packages[$idx]} ${versions[$idx]} ${sha256[$idx]}" >> "$1/versions.log"
        done
        if [ -n "$download" ] && [ "$download" = "true" ]; then
            cd "$1"
            apt-get "${APTOPT[@]}" download "${packages[@]}"
            cd -
        fi
        IFS=,
        json+="${metadata[*]}"']}'
        ;;
    ('/opt/resource/out')
        # Noop
        json='{}'
        ;;
esac

jq -n "$json" >&3
